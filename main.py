import os
import sys
import time
import urllib.parse
import argparse
import logging
from dataclasses import dataclass
from typing import List, Optional
from pathlib import Path
import xml.etree.ElementTree as ET

import requests
from dotenv import load_dotenv
import google.generativeai as genai

# ロギング設定
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# .envファイルから環境変数を読み込む
load_dotenv()

@dataclass
class SearchResult:
    """検索結果を保持するデータクラス"""
    title: str
    url: str
    summary: str
    source: str
    authors: str = ""
    date: str = ""

class ResearchAggregator:
    # HTMLレポートのテンプレート
    HTML_TEMPLATE = """<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Research Report: {query}</title>
    <style>
        body {{
            font-family: "Helvetica Neue", Arial, "Hiragino Kaku Gothic ProN", "Hiragino Sans", Meiryo, sans-serif;
            max-width: 900px;
            margin: 2rem auto;
            padding: 0 1rem;
            line-height: 1.6;
            color: #333;
            background-color: #f9fafb;
        }}
        h1 {{
            border-bottom: 3px solid #3b82f6;
            padding-bottom: 0.5rem;
            color: #1e3a8a;
            font-size: 1.8rem;
        }}
        h2 {{
            margin-top: 2.5rem;
            color: #2563eb;
            border-left: 5px solid #3b82f6;
            padding-left: 10px;
            font-size: 1.5rem;
        }}
        .meta-info {{
            margin-bottom: 2rem;
            color: #6b7280;
            font-size: 0.9rem;
        }}
        .card {{
            background: #fff;
            padding: 1.5rem;
            margin-bottom: 1rem;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            transition: box-shadow 0.2s;
        }}
        .card:hover {{
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }}
        .title {{
            font-size: 1.25rem;
            font-weight: bold;
            margin-bottom: 0.5rem;
        }}
        .title a {{
            color: #2563eb;
            text-decoration: none;
        }}
        .title a:hover {{
            text-decoration: underline;
        }}
        .meta {{
            font-size: 0.85rem;
            color: #6b7280;
            margin-bottom: 0.5rem;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }}
        .meta span {{
            background-color: #f3f4f6;
            padding: 2px 8px;
            border-radius: 4px;
        }}
        .summary {{
            margin-top: 0.8rem;
            font-size: 0.95rem;
            color: #4b5563;
        }}
        .footer {{
            margin-top: 50px;
            text-align: center;
            color: #9ca3af;
            font-size: 0.8rem;
            border-top: 1px solid #e5e7eb;
            padding-top: 20px;
        }}
    </style>
</head>
<body>
    <h1>Research Report</h1>
    <div class="meta-info">
        <strong>Topic:</strong> {query} | <strong>Date:</strong> {current_date}
    </div>

    <h2>Google Search Results (Gemini Grounding)</h2>
    {google_html}

    <h2>CiNii Research Results (Japanese Academic)</h2>
    {cinii_html}
    
    <div class="footer">
        Generated by Python Research Aggregator (Refactored Version)
    </div>
</body>
</html>"""

    def __init__(self, api_key: str):
        if not api_key:
            raise ValueError("API Key is not provided.")
        # ライブラリの初期設定
        genai.configure(api_key=api_key)
        self.output_dir = Path("reports")
        self.output_dir.mkdir(exist_ok=True)

    def search_google(self, query: str) -> List[SearchResult]:
        """GeminiのGrounding機能を使ってWeb検索を行う"""
        logger.info(f"Searching Google for: {query}...")
        try:
            # google-generativeai ライブラリでのモデル初期化
            model = genai.GenerativeModel(
                model_name="gemini-1.5-flash",
                tools='google_search_retrieval'
            )
            
            response = model.generate_content(
                f"Find 5 high-quality, relevant web pages or PDFs regarding: '{query}'. Return the results as a list."
            )
            
            results = []
            if response.candidates and response.candidates[0].grounding_metadata:
                metadata = response.candidates[0].grounding_metadata
                if hasattr(metadata, 'grounding_chunks'):
                    for chunk in metadata.grounding_chunks:
                        if chunk.web and chunk.web.uri and chunk.web.title:
                            results.append(SearchResult(
                                title=chunk.web.title,
                                url=chunk.web.uri,
                                summary="Google Search Result (Gemini Grounding)",
                                source="Google"
                            ))
            
            # URLで重複排除
            unique_results = {r.url: r for r in results}.values()
            return list(unique_results)
            
        except Exception as e:
            logger.error(f"Error in Google Search: {e}")
            return []

    def search_cinii(self, query: str) -> List[SearchResult]:
        """CiNii Research OpenSearch APIを使って論文・図書を検索する"""
        logger.info(f"Searching CiNii for: {query}...")
        time.sleep(1) # APIへの配慮
        try:
            encoded_query = urllib.parse.quote(query)
            # RSSフォーマットを指定
            url = f"https://cir.nii.ac.jp/opensearch/all?q={encoded_query}&format=rss&count=5"
            response = requests.get(url)
            
            if response.status_code != 200:
                logger.error(f"CiNii API Error: {response.status_code}")
                return []

            # XMLパース
            root = ET.fromstring(response.content)
            results = []
            
            # 名前空間の定義 (RSS 1.0)
            ns = {
                'rss': 'http://purl.org/rss/1.0/',
                'rdf': 'http://www.w3.org/1999/02/22-rdf-syntax-ns#',
                'dc': 'http://purl.org/dc/elements/1.1/',
                'prism': 'http://prismstandard.org/namespaces/1.2/basic/'
            }

            items = root.findall('rss:item', ns)
            
            for item in items:
                title = self._get_text(item, 'rss:title', ns, "No Title")
                link = self._get_text(item, 'rss:link', ns, "")
                summary = self._get_text(item, 'rss:description', ns, "No description available.")
                
                # 著者の取得
                authors = []
                for creator in item.findall('dc:creator', ns):
                    if creator is not None and creator.text:
                        authors.append(creator.text)
                
                # 出版日
                date_str = self._get_text(item, 'prism:publicationDate', ns, "")

                results.append(SearchResult(
                    title=title,
                    url=link,
                    summary=(summary[:300] + "...") if len(summary) > 300 else summary,
                    source="CiNii",
                    authors=", ".join(authors),
                    date=date_str
                ))
                
            return results

        except Exception as e:
            logger.error(f"Error in CiNii Search: {e}", exc_info=True)
            return []

    def _get_text(self, element: ET.Element, tag: str, ns: dict, default: str) -> str:
        """XML要素からテキストを安全に取得するヘルパーメソッド"""
        found = element.find(tag, ns)
        if found is not None and found.text:
            return found.text.strip()
        return default

    def _format_html_card(self, results: List[SearchResult]) -> str:
        """検索結果リストをHTMLカード形式に変換する"""
        if not results:
            return '<p>No results found.</p>'
        
        cards = []
        for r in results:
            meta_parts = []
            if r.source == "CiNii":
                if r.authors: meta_parts.append(f"Authors: {r.authors}")
                if r.date: meta_parts.append(f"Date: {r.date}")
            else:
                meta_parts.append(r.url)

            meta_html = "".join([f"<span>{m}</span>" for m in meta_parts])
            
            card = f"""
            <div class="card">
                <div class="title"><a href="{r.url}" target="_blank">{r.title}</a></div>
                <div class="meta">{meta_html}</div>
                <div class="summary">{r.summary}</div>
            </div>
            """
            cards.append(card)
        return "".join(cards)

    def generate_html_report(self, query: str, google_results: List[SearchResult], cinii_results: List[SearchResult]) -> None:
        """検索結果をHTMLファイルにまとめる"""
        current_date = time.strftime('%Y-%m-%d')
        
        google_html = self._format_html_card(google_results)
        cinii_html = self._format_html_card(cinii_results)

        html_content = self.HTML_TEMPLATE.format(
            query=query,
            current_date=current_date,
            google_html=google_html,
            cinii_html=cinii_html
        )

        filename = f"report_{query.replace(' ', '_')}.html"
        filepath = self.output_dir / filename

        try:
            with open(filepath, "w", encoding="utf-8") as f:
                f.write(html_content)
            logger.info(f"Report generated successfully: {filepath.absolute()}")
            print(f"\n✨ Report generated successfully: {filepath}")
        except Exception as e:
            logger.error(f"Error writing report file: {e}")

    def run(self, query: Optional[str] = None):
        print("=== Python Research Aggregator (Refactored) ===")
        
        if not query:
            query = input("Enter research topic: ").strip()
        
        if not query:
            logger.warning("Query is empty. Exiting.")
            return

        # 検索実行
        g_results = self.search_google(query)
        c_results = self.search_cinii(query)

        # レポート作成
        self.generate_html_report(query, g_results, c_results)

def parse_arguments():
    parser = argparse.ArgumentParser(description="Generate a research report from Google and CiNii.")
    parser.add_argument("query", nargs="?", help="The research topic to search for.")
    return parser.parse_args()

if __name__ == "__main__":
    # 環境変数からAPIキーを取得 (GOOGLE_API_KEYを優先)
    API_KEY = os.getenv("GOOGLE_API_KEY") or os.getenv("GEMINI_API_KEY")

    if not API_KEY:
        logger.critical("Error: 環境変数 'GOOGLE_API_KEY' (または 'GEMINI_API_KEY') が見つかりません。")
        print("Error: .env ファイルを作成し、GOOGLE_API_KEY=your_api_key_here を記述してください。")
        sys.exit(1)

    try:
        args = parse_arguments()
        app = ResearchAggregator(api_key=API_KEY)
        app.run(query=args.query)
    except ValueError as e:
        logger.error(f"Configuration Error: {e}")
    except Exception as e:
        logger.critical(f"Unexpected Error: {e}", exc_info=True)